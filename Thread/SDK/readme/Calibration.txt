



 +=====================================================================================+
 +																					   +
						 		   ADE7878 校表流程
 +																						+
 +======================================================================================+

 					          
   针对电量测试芯片的软件校准经历了月余，现在是时候总结一下这款芯片的使用和校准流程了。
   可以通过IIC和SPI接口
   选择SPI接口并调配到一个比较低的速率上400K-400HZ。
   完成这些之后可以打印出来其中一相电的电参数比如电流电压和瞬时的功率。我开始面对这些
   数据毫无头绪。我不知道该如何去做。我不知道下一步该干什么？该如何去实现？
   这也是写这些的意义所在。切记弯路曲折啊。


一、校准的方法

	如何把这些凌乱的数据调整为按照实际规律变化的有用的电能的数据呢？于是我首先想到了一个
	简单的办法那就是我打印出来电流寄存器的值然后用万用表测量一个电流数据然后将他们之比K
	必然正比于实际的电能于是就可以算出来当前的实际电流。

   1、系数法

   接入一个纯阻性负载，串入电流表、电压表。
   同时采样电压表和电流表的电压电流值和打印出来的寄存器值
   利用中值滤波或者递推平均可以算出各个寄存器读取的平均值REG。
   同样的利用此算法可以求出对应的电压和电流值I和U。
   于是他们之间有这样的关系
   KI=REGi/I  &	  KU=REGi/U  
   在程序中只要把系数KI\KU代入即可计算出来当前的电压、电流的实际值。
   即：U=REGi/KU  I=REGi/KI

		    float KI=42529,Irms,KV=10429,KW=51,Vrms,Wwat,cos=1;
			uint16_t l1,l2,l3;
			  Irms = temp[1]/ KI;
			  Vrms = temp[2]/ KV;
			  Wwat= Vrms*Irms*cos;
			  Wwat = temp[3]/ KW;
			
			l1=sprintf(sfIrms,"%f",Irms);  
			l2=sprintf(sfVrms,"%f",Vrms);  
			l3=sprintf(sfWatt,"%f",Wwat);  

	这种直接出来结果，但是似乎“幸福来得太突然”我不敢接受，在读取电能的时候我凌乱了，我不知道该给电能寄存器
	乘以一个什么样的系数了。这条路看似鲜花盛开走下去究竟是这么扯蛋啊。不得不重新思考并读datasheet。直到看到那个
	电流和电压通道的框图，那图显示了电信号从输入到寄存器的路径。中间有些节点有运算，有寄存器，而这些参与计算的
	寄存器就是解决校准问题的关键，于是就引出了第二种方法

	2、寄存器法

	利用电压或者电流通道上的这些寄存器可以对输入的信号进行修正以达到期望输出的值。然后只要操作这些寄存器就可以
	完成对电表的校准。这才是正路子吧。心花怒放一下找到了前进方向。
	可是如何去操作这些寄存呢？
	怎么把他们和实际的电流相对应？这又是一个大大的问号！！！
	校准之前必须解除这个问题，那就是如何把实际的电参数正比于当前寄存器的值。 查阅了一些资料，尤其去百度了一下
	结果发现他们的校准烂的一塌糊涂，我直接看不懂，也不能理解他们的做法。知道看手册说 VrmsREF =220 × 10^4 
	显然把实际值放大了10000	倍作为寄存器的值，这个值直接正比于实际的电压电流，并且是10的正整数倍。
	所以问题就变得简单了，只要乘以10的多少次方就解决了。


 二、参数计算（CFxDEN、IFS和VFS）
 	一块电表肯定要表这么几个参数、一是他可以测量多大的电流、二是他的输入电压是多少、三是走1度电转多少圈或者多少脉冲。
	所以必须先要计算这几个参数。
	一般表述为

		电表通常用标称电流(IN)、标称电压(VN)和电表常数(MC)
		来表征。电表常数指的是对于每千瓦时(kWh)的电能消耗。

		这几个参数对累积的电能有至关重要的意义，必须认真的计算咯。（后面WTHR的操作再说）

	  1、IFS的计算
	  最大电流的计算这取决于硬件的配置，我很幸运硬件也是我自己画的PCB，所以我在开始的时候对硬件就了解了，
	  写代码了再去要原理图，咱早就知道了。
	  现在使用兵子的50A:1mA的电流互感器CT。RL=200R的负载电阻。求Ifs.已知ADE7878的输入电压最高0.5V（峰值）
      首先求出来在达到峰值的时的上的压降是0.5V时对应的有效值。
			 Vrms=0.5/√2=0.3536V
			 有如下关系
			 @Ifs/CT*RL=Vrms
			 数值代入上式可得
			 @Ifs/50000*200=0.3536V
			 解方程
			 @Ifs=88.4A
	 
	         这个值是有前提条件的。他的前提是芯片内的PGA增益为1的，必须是1，IFS=88.4A。
++++mark1++++ 实际上是我的PGA不能为1（为什么后面再说）在我的设定中PGA=2。
             所以
			 @IFS=88.4/2=44.2A
		 IFS通俗的讲就是最大IFS再大的话芯片输入量程就超了。
				
	  2、VFS的计算
	   现在使用兵子的电压互感器，说白了也是电流互感器，其原理是输入/输出=2MA/2MA,RL=200R的负载电阻.
	   已知ADE7878的输入电压最高0.5V（峰值）
	   类似的先求出来在达到峰值的时的上的压降是0.5V时对应的有效值。	
	   Vrms=0.5/√2=0.3536V
			   (Vfs/150k)*200R= Vrms=0.3536V
				Vfs= (0.3536V/200)*150k
				=265.2v
			   显然我没有计算进线圈的阻抗，也就是上式是线圈的阻抗=0的情况下，为了更加逼近实际，线圈也要算上，
			   可以采取这个办法测量一次侧的电压V1在测量二次侧在200R的压降V2就可以得到一个比例VT
			   用这个VT可以推算出来VFS的实际值了
			   实际测量VT=227/0.207=1096			
			   
			   VfS  = VT* Vrms
			        = 1096*0.3536
					= 387v

++++mark2++++ vfs=387???确定？NO，这个值仅仅是参考值，因为没有明确的变比无法算出准确的值，但是1096不是么？
			   是！但是他不准，因为万用表有误差，硬件采样电阻有误差，互感器有误差，这些误差累积起来就偏的
			   要命。所以他仅仅是大体上在这个电压附近，可能向上偏可能向下偏，仅作运算的时候的参考了。（后面再说）  


	  3、计算CFxDEN
				 CFxDEN是一个正整数，用于ADE7878的电能频率转换器
				模块。CF1DEN、CF2DEN和CF3DEN寄存器利用此值进行
				初始化。
				
							  CFxDEN = 10^3/(MC*10^α)
				
				  MC是电表常数，用“脉冲数/kWh”表示。
				10 ( < 0)决定各电能寄存器的1 LSB代表多少电能，如WATT-
				小时和VAR-小时等。
				例如，要校准的电表的MC = 6400脉冲/kWh，为了获得正整
				数CxFDEN，选择 α= -3。
				
							 CFxDEN = 10^3/(6400*10^-3)	=156
				
				 这里我们取MC=10000imp/kw.h
				
							 CFxDEN = 10^3/(10000*10^-3) = 100
				
				  于是这些参数就有了
				
				  标称电流(IN)~=0.45A (校准标称电流)
				  标称电压(VN)~=230v	  （校准标称电压）
				  电表常数(MC) =10000impkw.h
				  满量程电流(IFS)=44.2A
				  满量程电压(VFS)~=387V

 

 三、计算VLEVEL寄存器 （依据手册带入参数即可算出）

			   通道计算数据参考
		   VLEVEL =Vfs/Vn*491520
		          =387v/220V*491520
				  =0xD3174


 四、计算VxGAIN、IxGAIN、xVRMSOS、AIRMSOS、AWGAIN、WATTOS值
 
		 	 /*
     1、xVGAIN寄存器校准流程
	  配置A相电压通道的增益（用来校准VRMS值的偏差）
	   1、给A相通入一个标准电压Vn（实际是输入市电223V左右）
	   2、配置 AVGAIN值为0。配置AVRMSOS为0。
	   3、输出VRMS值（递推平均或者排序后中值滤波）
	   5、将输入的电压互感器采样电压进行转换为Vref=	223*10^4
	   6、然后读取当前的VRMS值=2365068
	   7、GAIN = (Vref/VRMS -1 )= {(223*10^4/2365068)-1}
	   		   =(-0.057109563023135064192657462702975)
	   	       =((+0.057109563023135064192657462702975)*2^23)结果转换为十六进制然后NOT，最后+1
			   =0xFFF8B0A3
	   8、再次测量VRMS寄存器值和预期值接近。OK完成校准。
	   9、真实的电压等于xVRMS寄存器的值除以10^4
	 */
 		SPIWrite4Bytes(AVGAIN,0xFFF8B0A3);//
	 /*	
	 2、xVRMSOS 寄存器校准流程
	   配置A相电压通道的增益之后再来校准这个寄存器。
	   1、给A相通入一个标准电压Vn=230V 需要测量的最小电压Vmin=0V
	   2、A相输入这个标准电压会产生一个VRMSn=230*10^4,当A相输入0V时也会对应一个噪声值实测VRMSmin=0x2f8
	   3、按理说输入是0V那么VRMS一定是0，但是并不是。所以需要校准到0.
	   4、根据公式： xVRMSOS =[((VRMSmin^2*Vn^2)-(VRMSn^2*Vmin^2)) /(128*(Vmin^2-Vn^2))]
	   						 =(0x2f8^2*230^2) /128*(-230^2)
	   						 =结果转换为十六进制然后NOT，最后+1
	   						 =0xFFFFEE60
	 */
	SPIWrite4Bytes(AVRMSOS ,0xFFFFEE60);//
	/*
	3、xIGAIN寄存器校准流程
	  配置A相电流通道的增益（用来校准IRMS值的偏差）
	   1、给A相通入一个标准电流In（实际是0.42A）
	   2、配置 AIGAIN值为0。配置AIRMSOS为0。PGA=2.
	   （因为计算WTHR的值决定，还有一个就是GAIN的值不能超过+1~-1之间超过也要调整PGA或者改硬件。相对改硬件PGA更实在）
	   3、输出IRMS值（递推平均或者排序后中值滤波）
	   5、将输入的电压互感器采样电压进行转换为Vref=	0.44763*10^4 
	   6、然后读取当前的IRMS值(37216)
	   10、GAIN = (Vref/VRMS -1 )= {(0.44763*10^4/37216)-1}
	   		   =(-0.87972108770421324161650902837489)
	   	       =((0.87972108770421324161650902837489)*2^23)结果转换为十六进制 NOT +1
			   = 0xFF8F654D
	   8、再次测量IRMS寄存器值和预期值接近。OK完成校准。
	   9、真实的电压等于xIRMS寄存器的值除以10^3
*/		 
		SPIWrite2Bytes(Gain,0x0001);  //PGA=2倍增益
		SPIWrite4Bytes(AIGAIN ,0xFF8F654D);//
		   /*			   
	4、xIRMSOS 寄存器校准流程
	   配置A相电压通道的增益之后再来校准这个寄存器。
	   1、给A相通入一个标准电流In=0.45A 需要测量的最小电流Imin=0A
	   2、A相输入这个标准电流会产生一个IRMSn=0.45*10^6,当A相输入0A时也会对应一个噪声值实测IRMSmin=0xA20
	   3、按理说输入是0V那么IRMS一定是0，但是并不是。所以需要校准到0.
	   4、根据公式： xIRMSOS =[((IRMSmin^2*In^2)-(IRMSn^2*Imin^2)) /(128*(Imin^2-In^2))]
	   						 =(0xA20^2*0.45^2) /128*(-0.45^2)
	   						 =结果转换为十六进制然后NOT，最后+1
	   						 =0xFFFF32D0
	 */
	SPIWrite4Bytes(AIRMSOS  ,0XFFFF32D0);//

	  
	没有必要执行基波有功电能校准，因为它们与针对总有功
	电能计算的增益和失调应相同。然而，为了实现出色的精
	度，仍然可以使用下面针对总有功电能校准所述的步骤校
	准基波有功电能。
	为了补偿电流互感器、电阻分压器和ADC所
	决定的幅度误差，需要校准增益寄存器，这可以全部通过
	xIGAIN和xVGAIN寄存器来完成。此外，xWGAIN寄存器
	还能补偿为ADE7878提供CLK信号的晶振所引起的时间测
	量误差。该误差通常较小，可忽略。这种情况下，如果已
	经得出xIGAIN和xVGAIN寄存器，则可以根据下式计算

    5、WGAIN寄存器的校准

   
  功增益就 WATTHRref就是应该的功率。 AWATTHR是读取的实际功率 。

	AWGAIN = （WATTHRref / AWATTHR）-1

	/*
			
			 AWATTref = 标准表的读数   101W
			 AWATT = ADE7878的当前读数 120.5W

		 AWGAIN= [（AWATTref/AWATT）-1]
		 	   =101/120.5 -1
			   =-0.16182572614107883817427385892116
			   =结果乘以2^23后转换为16进制，取反后+1.
			   =0xFFEB494C
		  	
	  */
	SPIWrite4Bytes(AWGAIN  ,0xFFEB494C);//
 
     6、WATTOS寄存器的校准
     电压电流的校准后此寄存器无需校准了。就基本已经为0了。



 五、 xWTHR 功率阀值寄存器门槛设定 （相当的重要）

	 这个门楷之重要完全决定了这块电表能否走准。计量误差的大小很大程度上来自这个寄存器的配置。
	 这个寄存器是又2个24位的寄存器组成的高低位48位寄存器。表述为：

	   
	   			 THR0=0x00000000
		xWTHR =	
		   	     THR1=0x00000000	  
			  
	   /*
	 				xWTHR 功率阀值的计算


							WTHR寄存器
				
					WTHR = (PMAX*fs*3600*10^n)/(Vfs*Ifs)
				
				
				 其中，fS = 8 kHz，即DSP用于计算瞬时功率的频率。
				 THR必须始终大于或等于PMAX――相电压和相电流具有
				满量程幅度时ADE7878计算的有功功率：
				
					PMAX = 33,516,139
				
				 如果THR小于PMAX，应调整VRMSREF或IRMSREF。
				
				
				PMAX = 33516139 = 0x1FF6A6B


				
++++mark1++++	(1)首先解释为什么PGA不能为1，如下 
				设PGA=1则
				xWTHR=(PMAX*fs*3600*10^n)/(ufs*Ifs)
					=33516139*8000*3600*10^-3/ 88.4A*387 
					= 965264803200/	34210.8
					= 0x1AE87A6(Ifs=88.4A)
				 显然
				 上面有句话叫做如果THR小于PMAX，应调整VRMSREF（VFS）或IRMSREF(IFS)。
				 则	THR=0x1AE87A6
				 	PMA=0x1FF6A6B
				显然这样向下溢出，不行，必须让PGA=2以向上移动这个门槛的阀值，所以才有了PGA=2的值.




++++mark2++++	(2)再来解释电压互感器误差引入的需要调整的值
				   必须反复的计算这个xWTHR值写入寄存器中然后对应的标准表进行走电能对比之间的误差。
				   如果标准表减去ADE7878测出来的是正数则应该吧VFS调整大，
				   如果标准表减去ADE7878测出来的是负则应该吧VFS调整小，
				   目标只有一个，就是逼近标准表，误差为0最好了，尽量的向他靠近。那样你的电表就是一个标准表了
				   值得注意的是VFS并非一定是可调的，要看IFS，这里IFS我可以通过固定的变比计算出来但是VFS计算出来的
				   本来就是不准的，不调整他调整谁呢！！！

				xWTHR=(PMAX*fs*3600*10^n)/(ufs*Ifs)
					=33516139*8000*3600*10^-3/ 44A*485V[反复计算逼近实际电能时停止]（387） +++++mark+++
					= 965264803200/21340
					= 0x2B2320C(Ifs=44.1A)
				整理得：
				THR0=0x00B2320C
				THR1=0x00000002	


	 				  
	 			 THR的值越接近PMAX值其累计电能速度越快，反之越慢，
				 应该使用标准表校准为每分钟内增加的电能基本一致即可
				 还有一种办法就是用脉冲，设置为标准表相同的脉冲输出
				 这样当这个值设定好了之后正好可以使ADE7878输出的脉冲等于标准表输出的CP即可完成校准
				 
													   
	 */
	SPIWrite4Bytes(WTHR0,0x00B2320C);
	SPIWrite4Bytes(WTHR1,0x00000002);  



   六、内部PGA增益表


   	/*
	名称：GAIN寄存器(地址0xE60F)
	 Bits------Name------Function-------Value
	[15:9] 	保留						 000 0000
	[8:6] 	PGA3[2:0]   相电压增益		 000
	[5:3] 	PGA2[2:0]	零序电流增益	 000
	[2:0] 	PGA1[2:0]	相电流增益		 000
						000: 增益 = 1。
						001: 增益 = 2。
						010: 增益 = 4。
						011: 增益 = 8。
						100: 增益 = 16。
	Note:默认为1倍增益。如果输入信号
	*/



										 比特电子
										 王均伟



